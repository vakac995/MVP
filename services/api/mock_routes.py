# Auto-generated by Lumenary
##############################################################################
# Dependencies
##############################################################################


from fastapi import Depends, FastAPI, HTTPException, Request, status, Body, UploadFile, File, Form
from fastapi.staticfiles import StaticFiles
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import HTMLResponse, Response

from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, FileResponse, HTMLResponse, Response
from fastapi.exceptions import RequestValidationError
from fastapi.security import OAuth2PasswordBearer

import sys
import os
import asyncio
import logging
import traceback
import contextvars
import httpx
import jwt
import json
import requests
from pathlib import Path
import builtins

from datetime import datetime, date, time, timedelta
from concurrent.futures import ThreadPoolExecutor
from typing import Callable, Any, TypeVar, Awaitable, List, Optional, Dict, Union, Literal, Annotated, Tuple, Set
from functools import partial, wraps
from uuid import UUID
import uuid

from solar.access import User
from solar.media import MediaFile

from api.utils import get_swagger_ui_html
from api.models import TokenExchangeRequest, TokenResponse, TokenValidationRequest, LogoutResponse

OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY")
ROUTER_BASE_URL = os.environ.get("ROUTER_BASE_URL")
SOLAR_APP_TOKEN_URL = f"{ROUTER_BASE_URL}/innerApp/oauth2/token"
SOLAR_APP_INTROSPECT_URL = f"{ROUTER_BASE_URL}/innerApp/oauth2/introspect"
REFRESH_TOKEN_COOKIE_NAME = "refresh_token"





from .models import GetAllProjectsOutputSchema, BodyProjectServiceGetProjectById, GetProjectByIdOutputSchema, BodyProjectServiceGetFeaturedProjects, GetFeaturedProjectsOutputSchema, BodyProjectServiceSearchProjects, SearchProjectsOutputSchema, BodyProjectServiceGetProjectsByCategory, GetProjectsByCategoryOutputSchema, BodyProjectServiceCreateProject, CreateProjectOutputSchema, BodyProjectServiceUpdateProject, UpdateProjectOutputSchema, BodyProjectServiceDeleteProject, DeleteProjectOutputSchema, BodyProjectServiceGetProjectStatistics, GetProjectStatisticsOutputSchema, BodyVotingServiceVoteForProject, VoteForProjectOutputSchema, BodyVotingServiceRemoveVoteForProject, RemoveVoteForProjectOutputSchema, BodyVotingServiceHasUserVoted, HasUserVotedOutputSchema, BodyVotingServiceGetProjectVoteCount, GetProjectVoteCountOutputSchema, GetUserVotesOutputSchema, BodyVotingServiceGetProjectVoters, GetProjectVotersOutputSchema, BodyDonationServiceCreateDonation, CreateDonationOutputSchema, BodyDonationServiceGetProjectDonations, GetProjectDonationsOutputSchema, BodyDonationServiceGetDonationStatistics, GetDonationStatisticsOutputSchema, GetUserDonationsOutputSchema, BodyDonationServiceGetRecentDonations, GetRecentDonationsOutputSchema, BodyDonationServiceGetTopDonorsForProject, GetTopDonorsForProjectOutputSchema, GetUserDonationTotalOutputSchema, BodyTimelineServiceGetProjectTimeline, GetProjectTimelineOutputSchema, BodyTimelineServiceCreateTimelineItem, CreateTimelineItemOutputSchema, BodyTimelineServiceUpdateTimelineItem, UpdateTimelineItemOutputSchema, BodyTimelineServiceDeleteTimelineItem, DeleteTimelineItemOutputSchema, BodyTimelineServiceReorderTimelineItems, ReorderTimelineItemsOutputSchema, BodyTimelineServiceGetTimelineItemById, GetTimelineItemByIdOutputSchema, BodyTimelineServiceGetRecentTimelineActivity, GetRecentTimelineActivityOutputSchema, BodyCommentServiceGetProjectComments, GetProjectCommentsOutputSchema, BodyCommentServiceGetTimelineItemComments, GetTimelineItemCommentsOutputSchema, BodyCommentServiceGetThreadedComments, GetThreadedCommentsOutputSchema, BodyCommentServiceCreateComment, CreateCommentOutputSchema, BodyCommentServiceUpdateComment, UpdateCommentOutputSchema, BodyCommentServiceDeleteComment, DeleteCommentOutputSchema, BodyCommentServiceGetRecentComments, GetRecentCommentsOutputSchema, BodyCommentServiceGetCommentCountForProject, GetCommentCountForProjectOutputSchema, GetUserCommentsOutputSchema, BodyCommentServiceSearchComments, SearchCommentsOutputSchema, GetAllBadgesOutputSchema, BodyBadgeServiceGetProjectBadges, GetProjectBadgesOutputSchema, BodyBadgeServiceGetUserBadges, GetUserBadgesOutputSchema, BodyBadgeServiceSetFeaturedBadge, SetFeaturedBadgeOutputSchema, RecalculateBadgesOutputSchema, BodyRegistrationServiceCheckUsernameAvailability, CheckUsernameAvailabilityOutputSchema, BodyRegistrationServiceCheckEmailAvailability, CheckEmailAvailabilityOutputSchema, BodyRegistrationServiceValidatePassword, ValidatePasswordOutputSchema, BodyRegistrationServiceRegisterUser, RegisterUserOutputSchema, BodyRegistrationServiceSendVerificationEmail, SendVerificationEmailOutputSchema, BodyRegistrationServiceVerifyEmail, VerifyEmailOutputSchema, GetRegistrationStatsOutputSchema, BodyRegistrationServiceUpdateUserProfile, UpdateUserProfileOutputSchema


###############################################################################
# Logging Setup
###############################################################################
import sys
from loguru import logger
from pathlib import Path
from typing import TypeVar
import traceback

def format_record(record):
    fmt = "{level:<5} | {message}"
    if record["exception"] is not None:
        exc_type, exc_value, exc_traceback = record["exception"]        
        tb_lines = traceback.extract_tb(exc_traceback)
        if tb_lines:
            last_frame = tb_lines[-1]
            error_info = (
                f'\nFile "{last_frame.filename}", line {last_frame.lineno}, in {last_frame.name}\n'
                f'  {last_frame.line}\n'
                f'{exc_type.__name__}: {exc_value}'
            )
            record["message"] += error_info
        
        record["exception"] = None
    
    return fmt + "\n"

logger.remove()
logger.add(
    sys.stderr,
    level="DEBUG",
    format=format_record,
    colorize=True
)

Path("../logs").mkdir(exist_ok=True)
logger.add(
    "../logs/fast_api.log",
    rotation="50 MB",
    retention="10 days",
    level="DEBUG",
    format=format_record
)

# need this to capture print statements
class InterceptHandler:
    def write(self, msg):
        if msg.strip():
            logger.info(msg.strip())
    
    def flush(self):
        pass

sys.stdout = InterceptHandler()

T = TypeVar('T')



##############################################################################
# General App
##############################################################################

app = FastAPI(
    title="zaJedno Caribrod",
    docs_url=None
)

###############################################################################
# Simple Request Logging Middleware
###############################################################################

@app.middleware("http")
async def log_requests(request: Request, call_next):
    request_id = str(uuid.uuid4())[:8]
    
    with logger.contextualize(request_id=request_id):
        start_time = datetime.utcnow()
        
        try:
            response = await call_next(request)
            process_time = (datetime.utcnow() - start_time).total_seconds()
            if "HEAD /docs" not in request.url.path:
              logger.info(f"{request.method} {request.url.path} ({response.status_code}) - {process_time:.3f}s")
            return response
        except Exception as e:
            process_time = (datetime.utcnow() - start_time).total_seconds()
            logger.exception(f"{request.method} {request.url.path} - Failed after {process_time:.3f}s")
            raise
            
###############################################################################
# Error Handler
###############################################################################
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler for unhandled errors"""
    logger.error(f"Unhandled exception on {request.method} {request.url.path}: {exc}", exc_info=True)
    
    # In production, don't expose error details
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={
            "error": "Internal Server Error",
            "message": "An unexpected error occurred"
        }
    )
    
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle pydantic validation errors"""
    logger.error(f"Validation error on {request.url.path}: {exc.errors()}")
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "error": "Validation Error",
            "message": "Invalid request parameters",
            "details": exc.errors()
        }
    )
    
@app.exception_handler(Exception)
async def handle_errors(request: Request, exc: Exception):
    logger.exception(f"Unhandled error: {type(exc).__name__}: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "Internal server error", "message": str(exc)}
    )

@app.exception_handler(RequestValidationError)
async def handle_validation_errors(request: Request, exc: RequestValidationError):
    logger.warning(f"Validation error: {exc.errors()}")
    return JSONResponse(
        status_code=422,
        content={"error": "Validation failed", "details": exc.errors()}
    )

# We need to put a token endpoint here, but we're injecting the token,
# so we'll just put a mock endpoint here.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/mockedTokenEndpoint/")
ENV = os.environ.get("ENV", "deployment")

def get_auth_origins():
    if ENV == "sandbox":
        origins = [
            os.environ.get("SANDBOX_FRONTEND_URL", ""),
            os.environ.get("SANDBOX_BACKEND_URL", ""),
        ]
    else:
        origins = [os.environ.get("PUBLIC_DOMAIN", "")]
    
    return [origin for origin in origins if origin]

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

async def auth_cors_middleware(request: Request, call_next):
    if request.url.path.startswith("/api/auth"):
        auth_origins = get_auth_origins()
        origin = request.headers.get("origin", "")
        response = await call_next(request)
        
        # override the wildcard CORS settings with strict origin checking
        if origin in auth_origins:
            response.headers["Access-Control-Allow-Origin"] = origin
            response.headers["Access-Control-Allow-Credentials"] = "true"
            response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
            response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, Accept"
            response.headers["Access-Control-Expose-Headers"] = "Set-Cookie"
        else:
            # unauthorized origins on auth routes, set CORS headers to blank or remove them
            response.headers["Access-Control-Allow-Origin"] = ""
            response.headers["Access-Control-Allow-Methods"] = ""
            response.headers["Access-Control-Allow-Headers"] = ""
            
        return response
    else:
        return await call_next(request)

# auth-specific middleware and logging middleware
app.middleware("http")(auth_cors_middleware)

# OPTIONS handler for auth endpoints
@app.options("/api/auth/{rest_of_path:path}", include_in_schema=False)
async def auth_options_handler(request: Request):
    auth_origins = get_auth_origins()
    origin = request.headers.get("origin", "")
    response = Response()
    
    if origin in auth_origins:
        response.headers["Access-Control-Allow-Origin"] = origin
        response.headers["Access-Control-Allow-Credentials"] = "true"
        response.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
        response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, Accept"
        response.headers["Access-Control-Max-Age"] = "3600"
    
    return response

@app.head("/docs", include_in_schema=False)
async def health_check():
    return {"status": "healthy"}
    
##############################################################################
# Synchronous Function Helpers
##############################################################################

thread_pool = ThreadPoolExecutor(max_workers=4)

async def run_sync_in_thread(func: Callable[..., Any], *args, **kwargs) -> Any:
    """Runs a synchronous function in a thread pool"""
    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(
        thread_pool,
        partial(func, *args, **kwargs)
    )


##############################################################################
# Custom Docs
##############################################################################

@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " on Solar",
        swagger_ui_parameters={
            "persistAuthorization": False,
            "syntaxHighlight": {"theme": "obsidian"},
        }
    )

##############################################################################
# Auth Routes
##############################################################################

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        base_url = os.getenv("ROUTER_BASE_URL")
        if not base_url:
            raise HTTPException(status_code=500, detail="ROUTER_BASE_URL is not set, could not authenticate user")
        decoded_token = jwt.decode(token, options={"verify_signature": False})
        token_url = f"{base_url}/innerApp/oauth2/introspect"
        async with httpx.AsyncClient(timeout=20.0) as client:
            response = await client.post(token_url, json={"token": decoded_token["jti"], "token_type_hint": "access_token"})
            if response.status_code != 200 or response.json()["active"] == False:
                raise HTTPException(status_code=401, detail="Unauthorized")
            json_response = response.json()
            user = User(id=json_response["userUuid"], email=json_response["email"])
            return user
    except Exception as e:
        print(f"get_current_user failed with error: {type(e).__name__}")
        raise HTTPException(status_code=401, detail="Unauthorized")

def extract_domain(url):
    if not url:
        return None
    
    # Remove protocol
    if url.startswith("http://"):
        url = url[7:]
    elif url.startswith("https://"):
        url = url[8:]
    
    # Remove trailing slash
    if url.endswith("/"):
        url = url[:-1]
    
    return url

@app.post('/api/auth/token', response_model=TokenResponse, include_in_schema=False)
async def exchange_token(request: Request, body: TokenExchangeRequest = Body(...)):    
    try:
        params = body.model_dump(exclude_none=True)
        if params.get("grant_type") == REFRESH_TOKEN_COOKIE_NAME:
            refresh_token = request.cookies.get(REFRESH_TOKEN_COOKIE_NAME)
            if not refresh_token:
                return JSONResponse(
                    status_code=401,
                    content={
                        "status": "auth_required",
                        "message": "Authentication required",
                        "token_type": "bearer",
                        "access_token": "",
                        "expires_in": 0
                    }
                )

            params[REFRESH_TOKEN_COOKIE_NAME] = refresh_token
        
        if params.get("grant_type") == REFRESH_TOKEN_COOKIE_NAME and params.get(REFRESH_TOKEN_COOKIE_NAME):
            try:
                refresh_token = params[REFRESH_TOKEN_COOKIE_NAME]
                payload = jwt.decode(refresh_token, options={"verify_signature": False})
                
                if payload and payload.get("jti"):
                    params[REFRESH_TOKEN_COOKIE_NAME] = payload["jti"]
            except Exception as e:
                logger.warning(f"Error extracting JTI from refresh token: {e}")

        response = requests.post(
            SOLAR_APP_TOKEN_URL,
            json=params,
            headers={"Content-Type": "application/json", "Accept": "application/json"}
        )
        
        if not response.ok:
            return JSONResponse(
                    status_code=401,
                    content={
                        "status": "auth_required",
                        "message": "Authorization code invalid or expired",
                        "token_type": "bearer",
                        "access_token": "",
                        "expires_in": 0
                    }
                )
        
        tokens = response.json()
        
        if not tokens.get("access_token"):
            raise APIError(message="Received incomplete token data from server")
        
        token_response = TokenResponse(
            access_token=tokens["access_token"],
            token_type=tokens.get("token_type", "bearer"),
            expires_in=tokens.get("expires_in", 3600)
        )
        
        content = token_response.model_dump()
        api_response = JSONResponse(content=content)
        
        if tokens.get(REFRESH_TOKEN_COOKIE_NAME):      
            if ENV == "sandbox" and not os.environ.get("SANDBOX_BACKEND_URL", None):
              raise APIError(message="Token exchange failed: sandbox frontend URL not set")
            
            if ENV == "deployment" and not os.environ.get("PUBLIC_DOMAIN", None):
              raise APIError(message="Token exchange failed: public domain not set")
            
            domain = None
            if ENV == "sandbox":
                domain = extract_domain(os.environ.get("SANDBOX_BACKEND_URL"))
            else:
                domain = extract_domain(os.environ.get("PUBLIC_DOMAIN"))

            api_response.set_cookie(
                key=REFRESH_TOKEN_COOKIE_NAME,
                value=tokens[REFRESH_TOKEN_COOKIE_NAME],
                httponly=True,
                secure=True,
                samesite="none" if ENV == "sandbox" else "strict",
                domain=domain,
                path="/api/auth"
            )
        
        return api_response
        
    except Exception as e:
        logger.error(f"Token exchange error: {str(e)}", exc_info=True)
        raise APIError(message=f"Token exchange failed: {str(e)}")


@app.post('/api/auth/logout', response_model=LogoutResponse, include_in_schema=False)
async def logout():
    response = JSONResponse(content={"success": True})
    
    if ENV == "sandbox" and not os.environ.get("SANDBOX_BACKEND_URL", None):
      raise APIError(message="Logout failed: sandbox frontend URL not set")
    
    if ENV == "deployment" and not os.environ.get("PUBLIC_DOMAIN", None):
      raise APIError(message="Logout failed: public domain not set")
    
    domain = None
    if ENV == "sandbox":
        domain = extract_domain(os.environ.get("SANDBOX_BACKEND_URL"))
    else:
        domain = extract_domain(os.environ.get("PUBLIC_DOMAIN"))
    
    response.delete_cookie(
        key=REFRESH_TOKEN_COOKIE_NAME,
        path="/api/auth",
        secure=True,
        httponly=True,
        samesite="none" if ENV == "sandbox" else "strict",
        domain=domain,
    )
    
    return response


##############################################################################
# Normal Routes
##############################################################################






@app.post('/api/project_service/get_all_projects', response_model=GetAllProjectsOutputSchema, operation_id='project_service_get_all_projects')
async def project_service_get_all_projects() -> GetAllProjectsOutputSchema:
    """
    Get all projects for public viewing.
    """
    pass




@app.post('/api/project_service/get_project_by_id', response_model=GetProjectByIdOutputSchema, operation_id='project_service_get_project_by_id')
async def project_service_get_project_by_id(body: BodyProjectServiceGetProjectById = Body(...)) -> GetProjectByIdOutputSchema:
    """
    Get a specific project by ID.
    """
    pass




@app.post('/api/project_service/get_featured_projects', response_model=GetFeaturedProjectsOutputSchema, operation_id='project_service_get_featured_projects')
async def project_service_get_featured_projects(body: BodyProjectServiceGetFeaturedProjects = Body(...)) -> GetFeaturedProjectsOutputSchema:
    """
    Get featured projects based on vote count and recent activity.
    """
    pass




@app.post('/api/project_service/search_projects', response_model=SearchProjectsOutputSchema, operation_id='project_service_search_projects')
async def project_service_search_projects(body: BodyProjectServiceSearchProjects = Body(...)) -> SearchProjectsOutputSchema:
    """
    Search projects by title, description, or tags.
    """
    pass




@app.post('/api/project_service/get_projects_by_category', response_model=GetProjectsByCategoryOutputSchema, operation_id='project_service_get_projects_by_category')
async def project_service_get_projects_by_category(body: BodyProjectServiceGetProjectsByCategory = Body(...)) -> GetProjectsByCategoryOutputSchema:
    """
    Get projects filtered by category.
    """
    pass




@app.post('/api/project_service/create_project', response_model=CreateProjectOutputSchema, operation_id='project_service_create_project')
async def project_service_create_project(body: BodyProjectServiceCreateProject = Body(...), current_user: User = Depends(get_current_user)) -> CreateProjectOutputSchema:
    """
    Create a new project.
    """
    pass




@app.post('/api/project_service/update_project', response_model=UpdateProjectOutputSchema, operation_id='project_service_update_project')
async def project_service_update_project(body: BodyProjectServiceUpdateProject = Body(...), current_user: User = Depends(get_current_user)) -> UpdateProjectOutputSchema:
    """
    Update an existing project (only by owner).
    """
    pass




@app.post('/api/project_service/delete_project', response_model=DeleteProjectOutputSchema, operation_id='project_service_delete_project')
async def project_service_delete_project(body: BodyProjectServiceDeleteProject = Body(...), current_user: User = Depends(get_current_user)) -> DeleteProjectOutputSchema:
    """
    Delete a project (only by owner).
    """
    pass




@app.post('/api/project_service/get_project_statistics', response_model=GetProjectStatisticsOutputSchema, operation_id='project_service_get_project_statistics')
async def project_service_get_project_statistics(body: BodyProjectServiceGetProjectStatistics = Body(...)) -> GetProjectStatisticsOutputSchema:
    """
    Get statistics for a project including votes, donations, comments.
    """
    pass




@app.post('/api/voting_service/vote_for_project', response_model=VoteForProjectOutputSchema, operation_id='voting_service_vote_for_project')
async def voting_service_vote_for_project(body: BodyVotingServiceVoteForProject = Body(...), current_user: User = Depends(get_current_user)) -> VoteForProjectOutputSchema:
    """
    Vote for a project (one vote per user per project).
    """
    pass




@app.post('/api/voting_service/remove_vote_for_project', response_model=RemoveVoteForProjectOutputSchema, operation_id='voting_service_remove_vote_for_project')
async def voting_service_remove_vote_for_project(body: BodyVotingServiceRemoveVoteForProject = Body(...), current_user: User = Depends(get_current_user)) -> RemoveVoteForProjectOutputSchema:
    """
    Remove vote for a project.
    """
    pass




@app.post('/api/voting_service/has_user_voted', response_model=HasUserVotedOutputSchema, operation_id='voting_service_has_user_voted')
async def voting_service_has_user_voted(body: BodyVotingServiceHasUserVoted = Body(...), current_user: User = Depends(get_current_user)) -> HasUserVotedOutputSchema:
    """
    Check if user has voted for a specific project.
    """
    pass




@app.post('/api/voting_service/get_project_vote_count', response_model=GetProjectVoteCountOutputSchema, operation_id='voting_service_get_project_vote_count')
async def voting_service_get_project_vote_count(body: BodyVotingServiceGetProjectVoteCount = Body(...)) -> GetProjectVoteCountOutputSchema:
    """
    Get the total vote count for a project.
    """
    pass




@app.post('/api/voting_service/get_user_votes', response_model=GetUserVotesOutputSchema, operation_id='voting_service_get_user_votes')
async def voting_service_get_user_votes(current_user: User = Depends(get_current_user)) -> GetUserVotesOutputSchema:
    """
    Get all votes by a user.
    """
    pass




@app.post('/api/voting_service/get_project_voters', response_model=GetProjectVotersOutputSchema, operation_id='voting_service_get_project_voters')
async def voting_service_get_project_voters(body: BodyVotingServiceGetProjectVoters = Body(...)) -> GetProjectVotersOutputSchema:
    """
    Get recent voters for a project (for displaying).
    """
    pass




@app.post('/api/donation_service/create_donation', response_model=CreateDonationOutputSchema, operation_id='donation_service_create_donation')
async def donation_service_create_donation(body: BodyDonationServiceCreateDonation = Body(...), current_user: User = Depends(get_current_user)) -> CreateDonationOutputSchema:
    """
    Create a donation for a project.
    """
    pass




@app.post('/api/donation_service/get_project_donations', response_model=GetProjectDonationsOutputSchema, operation_id='donation_service_get_project_donations')
async def donation_service_get_project_donations(body: BodyDonationServiceGetProjectDonations = Body(...)) -> GetProjectDonationsOutputSchema:
    """
    Get donations for a project.
    """
    pass




@app.post('/api/donation_service/get_donation_statistics', response_model=GetDonationStatisticsOutputSchema, operation_id='donation_service_get_donation_statistics')
async def donation_service_get_donation_statistics(body: BodyDonationServiceGetDonationStatistics = Body(...)) -> GetDonationStatisticsOutputSchema:
    """
    Get donation statistics for a project.
    """
    pass




@app.post('/api/donation_service/get_user_donations', response_model=GetUserDonationsOutputSchema, operation_id='donation_service_get_user_donations')
async def donation_service_get_user_donations(current_user: User = Depends(get_current_user)) -> GetUserDonationsOutputSchema:
    """
    Get all donations made by a user.
    """
    pass




@app.post('/api/donation_service/get_recent_donations', response_model=GetRecentDonationsOutputSchema, operation_id='donation_service_get_recent_donations')
async def donation_service_get_recent_donations(body: BodyDonationServiceGetRecentDonations = Body(...)) -> GetRecentDonationsOutputSchema:
    """
    Get recent donations across all projects (excluding anonymous ones).
    """
    pass




@app.post('/api/donation_service/get_top_donors_for_project', response_model=GetTopDonorsForProjectOutputSchema, operation_id='donation_service_get_top_donors_for_project')
async def donation_service_get_top_donors_for_project(body: BodyDonationServiceGetTopDonorsForProject = Body(...)) -> GetTopDonorsForProjectOutputSchema:
    """
    Get top donors for a project (excluding anonymous).
    """
    pass




@app.post('/api/donation_service/get_user_donation_total', response_model=GetUserDonationTotalOutputSchema, operation_id='donation_service_get_user_donation_total')
async def donation_service_get_user_donation_total(current_user: User = Depends(get_current_user)) -> GetUserDonationTotalOutputSchema:
    """
    Get total amount donated by a user.
    """
    pass




@app.post('/api/timeline_service/get_project_timeline', response_model=GetProjectTimelineOutputSchema, operation_id='timeline_service_get_project_timeline')
async def timeline_service_get_project_timeline(body: BodyTimelineServiceGetProjectTimeline = Body(...)) -> GetProjectTimelineOutputSchema:
    """
    Get timeline items for a project, ordered by order_index.
    """
    pass




@app.post('/api/timeline_service/create_timeline_item', response_model=CreateTimelineItemOutputSchema, operation_id='timeline_service_create_timeline_item')
async def timeline_service_create_timeline_item(body: BodyTimelineServiceCreateTimelineItem = Body(...), current_user: User = Depends(get_current_user)) -> CreateTimelineItemOutputSchema:
    """
    Create a new timeline item for a project.
    """
    pass




@app.post('/api/timeline_service/update_timeline_item', response_model=UpdateTimelineItemOutputSchema, operation_id='timeline_service_update_timeline_item')
async def timeline_service_update_timeline_item(body: BodyTimelineServiceUpdateTimelineItem = Body(...), current_user: User = Depends(get_current_user)) -> UpdateTimelineItemOutputSchema:
    """
    Update a timeline item (only by project owner).
    """
    pass




@app.post('/api/timeline_service/delete_timeline_item', response_model=DeleteTimelineItemOutputSchema, operation_id='timeline_service_delete_timeline_item')
async def timeline_service_delete_timeline_item(body: BodyTimelineServiceDeleteTimelineItem = Body(...), current_user: User = Depends(get_current_user)) -> DeleteTimelineItemOutputSchema:
    """
    Delete a timeline item (only by project owner).
    """
    pass




@app.post('/api/timeline_service/reorder_timeline_items', response_model=ReorderTimelineItemsOutputSchema, operation_id='timeline_service_reorder_timeline_items')
async def timeline_service_reorder_timeline_items(body: BodyTimelineServiceReorderTimelineItems = Body(...), current_user: User = Depends(get_current_user)) -> ReorderTimelineItemsOutputSchema:
    """
    Reorder timeline items for a project.
    """
    pass




@app.post('/api/timeline_service/get_timeline_item_by_id', response_model=GetTimelineItemByIdOutputSchema, operation_id='timeline_service_get_timeline_item_by_id')
async def timeline_service_get_timeline_item_by_id(body: BodyTimelineServiceGetTimelineItemById = Body(...)) -> GetTimelineItemByIdOutputSchema:
    """
    Get a specific timeline item by ID.
    """
    pass




@app.post('/api/timeline_service/get_recent_timeline_activity', response_model=GetRecentTimelineActivityOutputSchema, operation_id='timeline_service_get_recent_timeline_activity')
async def timeline_service_get_recent_timeline_activity(body: BodyTimelineServiceGetRecentTimelineActivity = Body(...)) -> GetRecentTimelineActivityOutputSchema:
    """
    Get recent timeline activity across all projects.
    """
    pass




@app.post('/api/comment_service/get_project_comments', response_model=GetProjectCommentsOutputSchema, operation_id='comment_service_get_project_comments')
async def comment_service_get_project_comments(body: BodyCommentServiceGetProjectComments = Body(...)) -> GetProjectCommentsOutputSchema:
    """
    Get all comments for a project, ordered by creation date.
    """
    pass




@app.post('/api/comment_service/get_timeline_item_comments', response_model=GetTimelineItemCommentsOutputSchema, operation_id='comment_service_get_timeline_item_comments')
async def comment_service_get_timeline_item_comments(body: BodyCommentServiceGetTimelineItemComments = Body(...)) -> GetTimelineItemCommentsOutputSchema:
    """
    Get comments for a specific timeline item.
    """
    pass




@app.post('/api/comment_service/get_threaded_comments', response_model=GetThreadedCommentsOutputSchema, operation_id='comment_service_get_threaded_comments')
async def comment_service_get_threaded_comments(body: BodyCommentServiceGetThreadedComments = Body(...)) -> GetThreadedCommentsOutputSchema:
    """
    Get threaded comments for a project or timeline item.
    """
    pass




@app.post('/api/comment_service/create_comment', response_model=CreateCommentOutputSchema, operation_id='comment_service_create_comment')
async def comment_service_create_comment(body: BodyCommentServiceCreateComment = Body(...), current_user: User = Depends(get_current_user)) -> CreateCommentOutputSchema:
    """
    Create a new comment on a project or timeline item.
    """
    pass




@app.post('/api/comment_service/update_comment', response_model=UpdateCommentOutputSchema, operation_id='comment_service_update_comment')
async def comment_service_update_comment(body: BodyCommentServiceUpdateComment = Body(...), current_user: User = Depends(get_current_user)) -> UpdateCommentOutputSchema:
    """
    Update a comment (only by the comment author).
    """
    pass




@app.post('/api/comment_service/delete_comment', response_model=DeleteCommentOutputSchema, operation_id='comment_service_delete_comment')
async def comment_service_delete_comment(body: BodyCommentServiceDeleteComment = Body(...), current_user: User = Depends(get_current_user)) -> DeleteCommentOutputSchema:
    """
    Delete a comment (only by the comment author or project owner).
    """
    pass




@app.post('/api/comment_service/get_recent_comments', response_model=GetRecentCommentsOutputSchema, operation_id='comment_service_get_recent_comments')
async def comment_service_get_recent_comments(body: BodyCommentServiceGetRecentComments = Body(...)) -> GetRecentCommentsOutputSchema:
    """
    Get recent comments across all projects.
    """
    pass




@app.post('/api/comment_service/get_comment_count_for_project', response_model=GetCommentCountForProjectOutputSchema, operation_id='comment_service_get_comment_count_for_project')
async def comment_service_get_comment_count_for_project(body: BodyCommentServiceGetCommentCountForProject = Body(...)) -> GetCommentCountForProjectOutputSchema:
    """
    Get total comment count for a project.
    """
    pass




@app.post('/api/comment_service/get_user_comments', response_model=GetUserCommentsOutputSchema, operation_id='comment_service_get_user_comments')
async def comment_service_get_user_comments(current_user: User = Depends(get_current_user)) -> GetUserCommentsOutputSchema:
    """
    Get all comments made by a user.
    """
    pass




@app.post('/api/comment_service/search_comments', response_model=SearchCommentsOutputSchema, operation_id='comment_service_search_comments')
async def comment_service_search_comments(body: BodyCommentServiceSearchComments = Body(...)) -> SearchCommentsOutputSchema:
    """
    Search comments by content.
    """
    pass




@app.post('/api/badge_service/get_all_badges', response_model=GetAllBadgesOutputSchema, operation_id='badge_service_get_all_badges')
async def badge_service_get_all_badges() -> GetAllBadgesOutputSchema:
    """
    Get all available badges in the system.
    """
    pass




@app.post('/api/badge_service/get_project_badges', response_model=GetProjectBadgesOutputSchema, operation_id='badge_service_get_project_badges')
async def badge_service_get_project_badges(body: BodyBadgeServiceGetProjectBadges = Body(...)) -> GetProjectBadgesOutputSchema:
    """
    Get all badges for a specific project with badge details.
    """
    pass




@app.post('/api/badge_service/get_user_badges', response_model=GetUserBadgesOutputSchema, operation_id='badge_service_get_user_badges')
async def badge_service_get_user_badges(body: BodyBadgeServiceGetUserBadges = Body(...)) -> GetUserBadgesOutputSchema:
    """
    Get all badges for a specific user with badge details.
    """
    pass




@app.post('/api/badge_service/set_featured_badge', response_model=SetFeaturedBadgeOutputSchema, operation_id='badge_service_set_featured_badge')
async def badge_service_set_featured_badge(body: BodyBadgeServiceSetFeaturedBadge = Body(...)) -> SetFeaturedBadgeOutputSchema:
    """
    Set a badge as featured for a user&#39;s profile.
    """
    pass




@app.post('/api/badge_service/recalculate_badges', response_model=RecalculateBadgesOutputSchema, operation_id='badge_service_recalculate_badges')
async def badge_service_recalculate_badges() -> RecalculateBadgesOutputSchema:
    """
    Recalculate all badges for all users and projects (admin function).
    """
    pass




@app.post('/api/registration_service/check_username_availability', response_model=CheckUsernameAvailabilityOutputSchema, operation_id='registration_service_check_username_availability')
async def registration_service_check_username_availability(body: BodyRegistrationServiceCheckUsernameAvailability = Body(...)) -> CheckUsernameAvailabilityOutputSchema:
    """
    Check if a username is available and valid.
    """
    pass




@app.post('/api/registration_service/check_email_availability', response_model=CheckEmailAvailabilityOutputSchema, operation_id='registration_service_check_email_availability')
async def registration_service_check_email_availability(body: BodyRegistrationServiceCheckEmailAvailability = Body(...)) -> CheckEmailAvailabilityOutputSchema:
    """
    Check if an email is available and valid.
    """
    pass




@app.post('/api/registration_service/validate_password', response_model=ValidatePasswordOutputSchema, operation_id='registration_service_validate_password')
async def registration_service_validate_password(body: BodyRegistrationServiceValidatePassword = Body(...)) -> ValidatePasswordOutputSchema:
    """
    Validate password strength.
    """
    pass




@app.post('/api/registration_service/register_user', response_model=RegisterUserOutputSchema, operation_id='registration_service_register_user')
async def registration_service_register_user(body: BodyRegistrationServiceRegisterUser = Body(...)) -> RegisterUserOutputSchema:
    """
    Register a new user account.
    """
    pass




@app.post('/api/registration_service/send_verification_email', response_model=SendVerificationEmailOutputSchema, operation_id='registration_service_send_verification_email')
async def registration_service_send_verification_email(body: BodyRegistrationServiceSendVerificationEmail = Body(...)) -> SendVerificationEmailOutputSchema:
    """
    Send email verification (simulated for now).
    """
    pass




@app.post('/api/registration_service/verify_email', response_model=VerifyEmailOutputSchema, operation_id='registration_service_verify_email')
async def registration_service_verify_email(body: BodyRegistrationServiceVerifyEmail = Body(...)) -> VerifyEmailOutputSchema:
    """
    Verify user email address (simulated for now).
    """
    pass




@app.post('/api/registration_service/get_registration_stats', response_model=GetRegistrationStatsOutputSchema, operation_id='registration_service_get_registration_stats')
async def registration_service_get_registration_stats() -> GetRegistrationStatsOutputSchema:
    """
    Get registration statistics for admin dashboard.
    """
    pass




@app.post('/api/registration_service/update_user_profile', response_model=UpdateUserProfileOutputSchema, operation_id='registration_service_update_user_profile')
async def registration_service_update_user_profile(body: BodyRegistrationServiceUpdateUserProfile = Body(...)) -> UpdateUserProfileOutputSchema:
    """
    Update user profile information.
    """
    pass

